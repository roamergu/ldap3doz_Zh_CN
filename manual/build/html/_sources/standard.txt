#################################
Extended standard RFCs operations
#################################

The extend.standard namespace contains extended operation defined in current RFCs::

    extend.standard
        extend.standard.who_am_i()
        extend.standard.modify_password(user, old_password, new_password, hash_algorithm=None, salt=None)
        extend.standard.paged_search(search_base, search_filter, search_scope, dereference_aliases, attributes, size_limit, time_limit, types_only, get_operational_attributes, controls, paged_size, paged_criticality, generator)


To get the identity of the bound user::

    c = Connection(....)
    c.bind()
    i_am = c.extend.standard.who_am_i()

if who_am_i() returns an empty string an anonymous connection is bound.


To modify a user password::

    from ldap3 import Server, Connection, HASHED_SALTED_SHA256
    s = Server(...)
    c = Connection(s, ...)
    c.bind()  # bind as someone that has permission to change user's password
    new_password = c.extend.standard.modify_password('cn=test1,o=test', 'old_password', 'new_password', HASHED_SALTED_SHA256)  # a new password is set, hashed with sha256 and a random salt


A special case with modify_password is for LDAP servers that follow RFC3062. If you send the old password and do not specify
a new password, the server should generate a new password compliant with the server password policy::

    s = Server(...)
    c = Connection(s, ...)
    c.bind()  # bind as someone that has permission to change user's password
    new_password = c.extend.standard.modify_password('cn=test1,o=test', 'old_password')  # a new password is generated by the server if compliant with RFC3062


The extend.standard.paged_search() operation is a convenient wrapper for the simple paged search as specified in the
RFC2696. You can indicate how many entries will be read in the paged_size parameter (defaults to 100) and you get back
a *generator* for the entries.
If you set to False the generator parameter of the search will be fully executed before returning the results.
If generator is set to True (the default) any subsequent search will be executed only when you read all the previous
read entries, saving memory.

In the modify_password() extended operation you can specify an hashing algorithm, if your LDAP server use hashed password but don't compute the hash by itself. Otherwise you can send the password and the server will hash it.

Algorithms names are defined in the ldap3 module. You can choose between:

* HASHED_NONE (no hashing is performed, password is sent in plain text)
* HASHED_MD5
* HASHED_SHA
* HASHED_SHA256
* HASHED_SHA384
* HASHED_SHA512
* HASHED_SALTED_MD5
* HASHED_SALTED_SHA
* HASHED_SALTED_SHA256
* HASHED_SALTED_SHA384
* HASHED_SALTED_SHA512

If you don't specify a *salt* parameter a random salt will be generated by the ldap3 library. Keep in mind that only
salted password can provide a strong level of security against dictionary attacks.

To directly modify the userPassword attribute via a modify operation you probably have to send the hashed password.
In this case you can use the hashed() function in the ldap3.utils.hashed package::

     from ldap3 import HASHED_SALTED_SHA
     from ldap3.utils.hashed import hashed

     hashed_password = hashed(HASHED_SALTED_SHA, 'new_password')
     c.modify('cn=user1,o=test', {'userPassword': [(MODIFY_REPLACE,[hashed_password])]})
